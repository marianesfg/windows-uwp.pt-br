---
Description: O Windows 10, build 10240, e as atualizações das ferramentas de desenvolvedor continuarão a fornecer as ferramentas, os recursos e as experiências da Plataforma Universal do Windows.
title: Novidades no Windows 10 build 10240 – julho de 2015
keywords: novidades, o que há de novo, atualizar, atualizações, recursos, novo, Windows 10, 1507, 10240
ms.date: 11/02/2017
ms.topic: article
ms.assetid: 4853e55b-2232-4589-903a-ccb60e07aeb8
ms.localizationpriority: medium
ms.openlocfilehash: 28eb1dfecf9f6648bd43606c541daf7b57960771
ms.sourcegitcommit: 6f32604876ed480e8238c86101366a8d106c7d4e
ms.translationtype: HT
ms.contentlocale: pt-BR
ms.lasthandoff: 06/21/2019
ms.locfileid: "67320442"
---
# <a name="whats-new-in-windows10-for-developers-build-10240"></a>Novidades no Windows 10 para desenvolvedores, build 10240

O Windows 10, build 10240, e o SDK atualizado fornecem as ferramentas, os recursos e as experiências para a criação de aplicativos incríveis da UWP (Plataforma Universal do Windows). Depois de [instalar as ferramentas e o SDK](https://go.microsoft.com/fwlink/?LinkId=821431) no Windows 10, você estará pronto para [criar um aplicativo Universal do Windows](../get-started/create-uwp-apps.md) ou descobrir como pode usar seu [código de aplicativo existente no Windows](../porting/index.md).

Confira uma análise das novidades, recurso por recurso, do Windows 10 build 10240 (também conhecido como Windows 10 versão 1507).

## <a name="adaptive-layouts"></a>Layouts adaptáveis

Recurso | Descrição
 :---- | ----:
Vários modos de exibição para conteúdo personalizado | O XAML oferece novo suporte para a definição de modos de exibição personalizados (arquivos .xaml) que compartilham o mesmo arquivo de código. Com isso, fica mais fácil para você criar e manter diferentes modos de exibição que são personalizados para uma família de dispositivos ou um cenário específico. Se seu aplicativo tem conteúdo de interface do usuário distinto, layout ou modelos de navegação que são bastante diferentes para diferentes cenários, crie vários modos de exibição. Por exemplo, você pode usar um [Pivot](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Controls.Pivot) com navegação otimizada para uso com uma mão em seu aplicativo móvel, mas deve usar um [SplitView](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Controls.SplitView) com um menu de navegação otimizado para mouse em seu aplicativo da área de trabalho.
StateTriggers | Usando o novo recurso [VisualState.StateTriggers](https://docs.microsoft.com/uwp/api/windows.ui.xaml.visualstate.statetriggers), você pode definir propriedades condicionalmente com base na altura/largura da janela ou com base em um gatilho personalizado. Anteriormente, você precisava manipular os eventos [SizeChanged](https://docs.microsoft.com/uwp/api/windows.ui.xaml.window.sizechanged) de janela no código e chamar [VisualStateManager.GotoState](https://docs.microsoft.com/uwp/api/windows.ui.xaml.visualstatemanager.gotostate).
Setters | Usando a nova sintaxe [VisualState.Setters](https://docs.microsoft.com/uwp/api/windows.ui.xaml.visualstate.setters), você pode usar a marcação simplificada para definir alterações de propriedade no [VisualStateManager](https://docs.microsoft.com/uwp/api/windows.ui.xaml.visualstatemanager). Anteriormente, você precisava usar um Storyboard e criar animações para aplicar alterações de propriedade, como mudança da orientação de um [StackPanel](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.stackpanel) de Horizontal para Vertical. Em aplicativos Universais do Windows, você pode usar esta sintaxe Setter mais simples: <setter target="stackPanel1.Orientation" value="Vertical" />


## <a name="xaml-features"></a>Recursos XAML

Recurso | Descrição
 :---- | :----
Vinculações de dados compilados (x:Bind) | Em aplicativos Universais do Windows, você pode usar o novo mecanismo de associação com base em compilador habilitado pela propriedade x:Bind. As vinculações com base em compilador são fortemente tipadas e processadas no momento da compilação, o que é mais rápido e fornece erros de tempo de compilação quando os tipos de vinculação são incompatíveis. E como as associações são convertidas em código de aplicativo compilado, agora você pode depurar as associações percorrendo o código no Visual Studio para diagnosticar problemas específicos de associação. Você também pode usar o x:Bind para associar a um método, assim: <textblock text="{x:Bind Customer.Address.ToString()}" /> Para cenários de associação comuns, você pode usar o x:Bind no lugar da associação e obter melhor desempenho e capacidade de manutenção.
Renderização incremental declarativa de listas (x:Phase) | Em aplicativos Universais do Windows, o novo atributo x:Phase permite realizar uma renderização de listas incremental ou em fases usando XAML em vez de código. Ao fazer movimento panorâmico de longas listas com itens complexos, seu aplicativo talvez não consiga renderizar itens de forma rápida o suficiente para acompanhar a velocidade do movimento panorâmico, provocando uma experiência ruim para seus usuários. A renderização em fases permite especificar a prioridade de renderização de elementos individuais em um item de lista, para que somente as partes mais importantes do item de lista são renderizadas em cenários de movimento panorâmico rápido. Isso proporciona uma experiência de movimento panorâmico mais suave para o usuário. <br /><br /> No Windows 8.1, você pode manipular o evento [ContainerContentChanging](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.listviewbase.containercontentchanging) e escrever um código para renderizar itens de lista em fases. Em aplicativos UWP, você pode fazer a renderização em fases declarativamente usando o atributo x:Phase. Usado em conjunto com vinculações compiladas x:Bind, o x:Phase permite especificar facilmente uma prioridade de renderização para cada elemento associado em um modelo de dados. No movimento panorâmico, o trabalho para renderizar itens tem o tempo dividido com base na fase, que permite a renderização incremental de itens.
Carregamento adiado de elementos de interface do usuário (x:deferLoadstrategy) | Em aplicativos Universais do Windows, a nova diretiva x:deferLoadstrategy permite especificar as partes da interface do usuário que terão o carregamento adiado, o que melhora o desempenho da inicialização e reduz o uso de memória de seu aplicativo. Por exemplo, se a interface do usuário de seu aplicativo tem um elemento para validação de dados que é mostrado somente quando dados incorretos são inseridos, você pode atrasar o carregamento desse elemento até que ele seja necessário. Assim, os objetos do elemento não são criados quando a página é carregada; em vez disso, eles são criados apenas quando há um erro de dados e não precisam ser adicionados à árvore visual da página.
SplitView | O novo controle [SplitView](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.splitview) oferece uma maneira de você mostrar e ocultar conteúdo transitório com facilidade. Ele costuma ser usado em cenários de navegação de nível superior como "menu hambúrguer", onde o conteúdo da navegação é ocultado e desliza quando necessário como resultado de uma ação do usuário.
RelativePanel | [RelativePanel](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.relativepanel) é um novo painel de layout que permite posicionar e alinhar os objetos filho em relação uns aos outros ou ao painel pai. Por exemplo, você pode especificar que um texto deve ser sempre posicionado no lado esquerdo do painel, e que um botão sempre deve estar alinhar abaixo do texto. Use ReleativePanel para criar interfaces do usuário que não tenham um padrão linear claro que exigiria o uso de [StackPanel](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.stackpanel) ou [Grid](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.grid).
CalendarView | O controle [CalendarView](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.calendarview) torna mais fácil exibir e selecionar datas e intervalos de datas com uma exibição personalizável baseada em meses. CalendarView oferece suporte a recursos como data mínima, data máxima e datas de blecaute para limitar quais datas podem ser selecionadas. Você também pode definir barras de densidade personalizadas que podem ser usadas para mostrar o "preenchimento" geral da agenda em um dia específico.
CalendarDatePicker | [CalendarDatePicker](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.calendardatepicker) é um controle suspenso que é otimizado para selecionar uma única data em uma CalendarView, onde informações contextuais como o dia da semana ou o preenchimento do calendário são importantes. Ele é similar ao controle [DatePicker](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.datepicker), mas o DatePicker é otimizado para selecionar uma data conhecida, como uma data de nascimento.
MediaTransportControls | A nova classe [MediaTransportControls](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.mediatransportcontrols) torna mais fácil personalizar os controles de transporte de um [MediaElement](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.mediaelement). No Windows 8.1, você pode ativar os controles de transporte internos do MediaElement ou criar seus próprios controles de transporte que se chamam métodos MediaElement. Agora você pode usar a funcionalidade interna de MediaTransportControls, e ainda personalizar facilmente a aparência de acordo com seu aplicativo.
Notificações de mudança de propriedade | Em aplicativos Universais do Windows, você pode ouvir as mudanças de propriedade em DependencyObjects, até mesmo para as propriedades que não tenham eventos de alteração correspondentes. A notificação funciona como um evento, mas na verdade é exposta como retorno de chamada. O retorno de chamada usa um argumento do remetente assim como um manipulador de eventos, mas não usa um argumento de evento. Em vez disso, apenas o identificador da propriedade é transmitido para indicar a propriedade. Com essas informações, seu aplicativo pode definir um único manipulador para várias notificações de propriedade. Para saber mais, consulte [RegisterPropertyChangedCallback](https://docs.microsoft.com/uwp/api/windows.ui.xaml.dependencyobject.registerpropertychangedcallback) e [UnregisterPropertyChangedCallback](https://docs.microsoft.com/uwp/api/windows.ui.xaml.dependencyobject.unregisterpropertychangedcallback).
Mapas | A classe [MapControl](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.maps.mapcontrol) foi atualizada para fornecer imagens aéreas 3D e exibições em nível de rua. Esses novos recursos e a funcionalidade de mapeamento anterior agora estão disponíveis para aplicativos Universais do Windows. Adicione mapeamento ao seu aplicativo com as seguintes APIs: [Windows.UI.Xaml.Controls.Maps](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.maps) e [Windows.Services.Maps](https://docs.microsoft.com/uwp/api/windows.services.maps). Para começar a usar essas APIs em um aplicativo Universal do Windows hoje, solicite uma chave da [Central de Desenvolvedores do Bing Mapas](https://www.bingmapsportal.com/). Para saber mais, consulte [Como autenticar um aplicativo Mapas](https://docs.microsoft.com/previous-versions/windows/apps/dn741528(v=win.10)). Outra novidade no Windows 10 é que os usuários de computador e telefone podem baixar mapas offline do aplicativo Configurações. Quando disponíveis, os mapas offline são usados pelo [MapControl](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.maps.mapcontrol) para exibir mapas quando não há acesso à Internet disponível.
Mapeamento de botões de entrada | A classe [Windows.UI.Xaml.Input.KeyEventArgs](https://docs.microsoft.com/uwp/api/windows.ui.xaml.input.keyroutedeventargs) tem uma nova propriedade [OriginalKey](https://docs.microsoft.com/uwp/api/windows.ui.xaml.input.keyroutedeventargs.originalkey) que, juntamente com uma atualização correspondente para [Windows.System.VirtualKey](https://docs.microsoft.com/uwp/api/windows.system.virtualkey), permite que você obtenha o botão de entrada original, não mapeado, associado ao evento de entrada do teclado.
Escrita à tinta | Agora é mais simples usar a funcionalidade robusta de escrita à tinta em aplicativos do Windows Runtime em C++, C# ou Visual Basic, graças ao controle [InkCanvas](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.inkcanvas) e às classes [InkPresenter](https://docs.microsoft.com/uwp/api/windows.ui.input.inking.inkpresenter) subjacentes. O controle [InkCanvas](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.inkcanvas) define uma área de sobreposição para desenhar e renderizar traços de tinta. A funcionalidade deste controle (entrada, processamento e renderização) vem das classes [InkPresenter](https://docs.microsoft.com/uwp/api/windows.ui.input.inking.inkpresenter), [InkStroke](https://docs.microsoft.com/uwp/api/windows.ui.input.inking.inkstroke), [InkRecognizers](https://docs.microsoft.com/uwp/api/windows.ui.input.inking.inkrecognizer) e [InkSynchronizer](https://docs.microsoft.com/uwp/api/windows.ui.input.inking.inksynchronizer). **Importante:** Essas classes não têm suporte em aplicativos do Windows que usam JavaScript.


## <a name="updated-xaml-features"></a>Recursos XAML atualizados

Recurso | Descrição
 :---- | :----
Atualizações de CommandBar e AppBar | Os controles [CommandBar](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.commandbar) e [AppBar](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.appbar) foram atualizados para ter API, comportamento e experiência do usuário consistentes para aplicativos UWP entre famílias de dispositivos. <br /><br />O controle CommandBar para aplicativos Universais do Windows foi aprimorado para fornecer um superconjunto da funcionalidade AppBar e maior flexibilidade em como você pode usá-lo em seu aplicativo. Você deve usar CommandBar para todos os novos aplicativos Universais do Windows no Windows 10. Em um CommandBar no Windows 8.1, você podia usar somente os controles que implementavam [ICommandBarElement](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.icommandbarelement), como [AppBarButton](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.appbarbutton). Em aplicativos Universais do Windows, agora você pode colocar conteúdo personalizado no CommandBar além de AppBarButtons. <br /><br />O controle AppBar foi atualizado para permitir que você mova mais facilmente seus aplicativos do Windows 8.1 que usam AppBar para a Plataforma Universal do Windows. O AppBar foi projetado para ser usado com aplicativos de tela inteira e ser invocado usando gestos de borda. As atualizações do controle referem-se a problemas como aplicativos de janela e a ausência de gestos de borda no Windows 10. <br /><br />O [AppBar.ClosedDisplayMode oculto](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.appbar.closeddisplaymode), antes somente no Windows Phone, agora é compatível com todas as famílias de dispositivos, permitindo que você escolha entre diferentes níveis de dicas para comandos. O AppBar mostra uma dica mínima por padrão para fornecer consistência ao atualizar seus aplicativos do Windows 8.1 para aplicativos Universais do Windows, onde você não pode mais contar com o suporte a gesto de borda na plataforma.
Atualizações do GridView | Antes do Windows 10, a orientação de layout padrão GridView era horizontal no Windows e vertical no Windows Phone. Em aplicativos UWP, GridView usa um layout vertical por padrão para todas as famílias de dispositivos para garantir que você tenha uma experiência padrão consistente.
Propriedade AreStickyGroupHeadersEnabled | Quando você mostra dados agrupados em [ListView](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.listview) ou [GridView](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.gridview), os cabeçalhos dos grupos agora permaneçam visíveis quando a lista é rolada. Isso é importante em grandes conjuntos de dados onde o cabeçalho fornece contexto para os dados que o usuário está visualizando. No entanto, em casos onde há apenas alguns elementos em cada grupo, você pode fazer com que os cabeçalhos rolem para fora da tela com os itens. Você pode definir a propriedade AreStickyGroupHeadersEnabled em [ItemsStackPanel](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.itemsstackpanel) e [ItemsWrapGrid](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.itemswrapgrid) para controlar esse comportamento.
Método GroupHeaderContainerFromItemContainer | Ao mostrar dados agrupados em [ItemsControl](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.itemscontrol), você pode chamar o método [GroupHeaderContainerFromItemContainer](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.itemscontrol.groupheadercontainerfromitemcontainer) para obter uma referência ao cabeçalho pai do grupo. Por exemplo, se um usuário excluir o último item em um grupo, você poderá obter uma referência para o cabeçalho do grupo e remover o item e o cabeçalho do grupo juntos.
Evento ChoosingGroupHeaderContainer | O novo evento [ChoosingGroupHeaderContainer](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.listviewbase.choosinggroupheadercontainer) em [ListViewBase](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.listviewbase) permite que você defina o estado em cabeçalhos de grupos em ListView ou GridView. Por exemplo, você pode manipular esse evento para definir a [AutomationProperties.Nameproperty](https://docs.microsoft.com/uwp/api/windows.ui.xaml.automation.automationproperties.nameproperty) no cabeçalho do grupo para representar o grupo de tecnologias assistenciais.
Evento ChoosingItemContainer | O novo evento [ChoosingItemContainer](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.listviewbase.choosingitemcontainer) em ListViewBase oferece maior controle sobre a virtualização da interface do usuário em [ListView](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.listview) ou [GridView](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.gridview). Use esse evento em conjunto com o evento [ContainerContentChanging](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.listviewbase.containercontentchanging) para manter sua própria fila de contêineres reciclados dos quais extrair dados conforme necessário. Por exemplo, se a fonte de dados for redefinida devido à filtragem, você poderá relacionar rapidamente um conjunto de elementos visuais (ItemContainers) já criado com seus dados para obter melhor desempenho.
Virtualização da rolagem de listas |Os controles XAML [ListView](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.listview) e [GridView](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.gridview) têm um novo evento [ListViewBase.ChooseingItemContainer](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.listviewbase.choosingitemcontainer) que melhora o desempenho do controle quando ocorre uma alteração na coleta de dados. Em vez de fazer uma restauração completa da lista, que repete a animação de entrada, agora o sistema mantém os itens atualmente em exibição, juntamente com o estado de seleção e foco; os itens novos e removidos no visor são animados e reduzidos facilmente. Após uma alteração na coleção de dados em que os contêineres não são destruídos, o aplicativo pode combinar itens "antigos" com seu contêiner anterior rapidamente e ignorar o processamento adicional de métodos de substituição do ciclo de vida do contêiner. Somente os "novos" itens são processados e associados a contêineres reciclados ou novos.
Método SelectRange e propriedade SelectedRanges | Em aplicativos Universais do Windows, os controles [ListView](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.listview) e [GridView](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.gridview) agora permitem que você selecione itens em termos de intervalos de índices de itens, em vez de referências a objetos de itens. Isso é uma maneira mais eficiente de descrever a seleção de itens porque os objetos de item não precisam ser criados para cada item selecionado. Para obter mais informações, consulte [ListViewBase.SelectedRanges](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.listviewbase.selectedranges), [ListViewBase.SelectRange](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.listviewbase.selectrange) e [ListViewBase.DeselectRange](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.listviewbase.deselectrange).
Novas APIs ListViewItemPresenter | [ListView](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.listview) e [GridView](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.gridview) usam apresentadores de itens para fornecer os elementos visuais padrão para seleção e foco. Em aplicativos UWP, [ListViewItemPresenter](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.primitives.listviewitempresenter) e [GridViewItemPresenter](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.primitives.gridviewitempresenter) têm novas propriedades que permitem que você personalize elementos visuais para itens de lista. As novas propriedades são CheckBoxBrush, CheckMode, FocusSecondaryBorderBrush, PointerOverForeground, PressedBackground e SelectedPressedBackground.
Atualizações de SemanticZoom | Agora o controle [SemanticZoom](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.semanticzoom) tem um comportamento consistente para aplicativos UWP em todas as famílias de dispositivos. A ação padrão para alternar entre a exibição ampliada e a exibição reduzida é tocar em um cabeçalho de grupo na exibição ampliada. Esse comportamento é o mesmo no Windows Phone 8.1, mas é uma alteração do Windows 8.1, que usava o gesto de pinça para aplicar zoom. Para alterar os modos de exibição usando pinçar para aplicar zoom, defina [ScrollViewer.ZoomMode](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.scrollviewer.zoommode)="Enabled" no ScrollViewer interno de SemanticZoom. <br /><br />Para aplicativos Universais do Windows, a exibição reduzida substitui a exibição ampliada e tem o mesmo tamanho da exibição que foi substituída. Esse comportamento é o mesmo no Windows 8.1, mas é uma alteração do Windows Phone 8.1, onde a exibição reduzida ocupava o tamanho total da tela e era renderizada sobre todos os outros tipos de conteúdo.
Atualizações de DatePicker e TimePicker | Agora os controles [DatePicker](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.datepicker) e [TimePicker](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.timepicker) têm uma implementação consistente para aplicativos Universais do Windows em todas as famílias de dispositivos. Eles também têm um novo visual para o Windows 10. A parte pop-up do controle agora usa os controles [DatePickerFlyout](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.datepickerflyout) e [TimePickerFlyout](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.timepickerflyout) em todos os dispositivos. Esse comportamento é o mesmo no Windows Phone 8.1, mas é uma alteração do Windows 8.1, que usava controles [ComboBox](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.combobox). O uso dos controles de submenu permite que você crie seletores de data e hora personalizados com facilidade.
Novas APIs ScrollViewer | [ScrollViewer](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.scrollviewer) tem novos eventos [DirectManipulationStarted](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.scrollviewer.directmanipulationstarted) e [DirectManipulationCompleted](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.scrollviewer.directmanipulationcompleted) para notificar seu aplicativo quando o movimento panorâmico por touch inicia e para. Você pode manipular esses eventos para coordenar sua interface do usuário com essas ações do usuário.
Atualizações de MenuFlyout | Em aplicativos Universais do Windows, há novas APIs que permitem que você crie menus de contexto melhores com mais facilidade. O novo método [MenuFlyout.ShowAt](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.menuflyout.showat) permite que você especifique onde deseja que o submenu apareça em relação a outro elemento. (E seu MenuFlyout ainda pode sobrepor os limites da janela do aplicativo.) Use a nova classe [MenuFlyoutSubItem](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.menuflyoutsubitem) para criar menus em cascata.
Novas propriedades de borda para ContentPresenter, Grid e StackPanel | Controles de contêiner comuns têm novas propriedades de borda que lhe permitem desenhar uma borda ao redor delas sem adicionar mais um elemento Border ao seu XAML. [ContentPresenter](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.contentpresenter), [Grid](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.grid) e [StackPanel](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.stackpanel) têm as seguintes propriedades novas: BorderBrush, BorderThickness, CornerRadius, e Padding.
Novas APIs de texto em ContentPresenter | [ContentPresenter](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.contentpresenter) tem novas APIs que lhe dão mais controle sobre a exibição de texto: LineHeight, LineStackingStrategy, MaxLines e TextWrapping.
Elementos visuais de foco do sistema | Agora os elementos visuais de foco para controles XAML são criados pelo sistema, em vez de ser declarados como elementos XAML no modelo de controle. Os elementos visuais de foco geralmente não são necessários em dispositivos móveis, e permitir que o sistema crie-os e gerencie-os conforme necessário melhora o desempenho do aplicativo. Se você precisar de maior controle sobre elementos visuais de foco, substitua o comportamento do sistema e forneça um modelo de controle personalizado que define os elementos visuais de foco. Veja [UseSystemFocusVisuals](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.control.usesystemfocusvisuals) e [IsTemplateFocusTarget](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.control.istemplatefocustargetproperty) para obter mais informações.
PasswordBox.PasswordRevealMode | Em aplicativos Universais do Windows, a propriedade [PasswordRevealMode](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.passwordbox.passwordrevealmode) substitui a propriedade IsPasswordRevealButtonEnabled para fornecer um comportamento consistente entre famílias de dispositivos. **Cuidado:** Antes do Windows 10, o botão para revelar a senha não era mostrado por padrão; nos aplicativos universais do Windows, ele é exibido por padrão. Se a segurança de seu aplicativo exigir que a senha esteja sempre oculta, certifique-se de definir PasswordRevealMode como Hidden.
Control.IsTextScaleFactorEnabled | A propriedade [IsTextScaleFactorEnabled](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.control.istextscalefactorenabledproperty) que estava disponível no Windows Phone 8.1 agora está disponível para aplicativos Universais do Windows em todas as famílias de dispositivos.
AutoSuggestBox | Agora o controle [AutoSuggestBox](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.autosuggestbox) do Windows Phone 8.1 está disponível para aplicativos Universais do Windows em todas as famílias de dispositivos, e você deve usá-lo no lugar de [SearchBox](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.searchbox). AutoSuggestBox fornece sugestões conforme o usuário digita e funciona bem com diversos tipos de entrada, como toque, teclado e editores de método de entrada. Ele também tem alguns novos membros para fazê-lo funcionar melhor como uma caixa de pesquisa: a propriedade [QueryIcon](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.autosuggestbox.queryicon) e o evento [QuerySubmitted](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.autosuggestbox.querysubmitted).
ContentDialog | Agora o controle [ContentDialog](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.contentdialog) do Windows Phone 8.1 está disponível para aplicativos Universais do Windows em todas as famílias de dispositivos. ContentDialog permite exibir uma caixa de diálogo modal personalizável que funcione bem em toda a gama de dispositivos.
Pivô | Agora o controle [Pivot](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.pivot) do Windows Phone 8.1 está disponível para aplicativos Universais do Windows em todas as famílias de dispositivos. Agora você pode usar o mesmo controle Pivot em seu aplicativo para dispositivos móveis e de área de trabalho. Pivot proporciona comportamento adaptável com base no tamanho da tela e no tipo de entrada. Você pode definir o estilo de um controle Pivot para fornecer o comportamento de guia, com diferentes modos de exibição de informações em cada item de pivô.

## <a name="text"></a>Texto

Recurso | Descrição
 :---- | :----
APIs de texto essenciais do Windows | O novo namespace [Windows.UI.Text.Core](https://docs.microsoft.com/uwp/api/windows.ui.text.core) tem um sistema cliente-servidor que centraliza o processamento das entradas do teclado em um único servidor. Você pode usá-lo para manipular o buffer de edição de seu controle de entrada de texto personalizado. O servidor de entrada de texto garante que o conteúdo de seu texto de controle de entrada e o conteúdo do seu próprio buffer de edição esteja sempre em sincronia, por meio de um canal de comunicação assíncrona entre o aplicativo e o servidor.
Ícones de vetor | O elemento [Glyphs](https://docs.microsoft.com/uwp/api/windows.ui.xaml.documents.glyphs) tem as novas propriedades [IsColorFontEnabled](https://docs.microsoft.com/uwp/api/windows.ui.xaml.documents.glyphs.iscolorfontenabled) e [ColorFontPalleteIndex](https://docs.microsoft.com/uwp/api/windows.ui.xaml.documents.glyphs.colorfontpaletteindex) para oferecer suporte a fontes coloridas; agora você pode usar um arquivo de fonte para renderizar ícones baseados em fontes. Quando você usa ColorFontPalleteIndex para alternância de paleta de cores, um único ícone pode ser renderizado com conjuntos de cores diferentes; por exemplo, para mostrar uma versão habilitada e desabilitada do ícone.
Eventos de janela do Editor de Método de Entrada | Às vezes, os usuários inserem texto por meio de um Editor de Método de Entrada que aparece em uma janela logo abaixo de uma caixa de entrada de texto (geralmente para idiomas do Leste Asiático). Você pode usar o evento CandidateWindowBoundsChanged e a propriedade DesiredCandidateWindowAlignment em [TextBox](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.textbox) e [RichEditBox](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.richeditbox) para fazer com que a interface do usuário de seu aplicativo funcione melhor com a janela do IME.
Eventos de composição de texto | [TextBox](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.textbox) e [RichEditBox](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.richeditbox) têm novos eventos para informar ao seu aplicativo quando o texto é composto usando um Editor de Método de Entrada: TextCompositionStarted, TextCompositionEnded e TextCompositionChanged. Você pode manipular esses eventos para coordenar o código do aplicativo com o processo de composição de texto do IME. Por exemplo, você pode implementar a funcionalidade de preenchimento automático embutida para idiomas do Leste Asiático.
Manuseio aprimorado de texto bidirecional | Os controles de texto XAML têm uma nova API para melhorar a manipulação de texto bidirecional, resultando em melhor alinhamento de texto e direcionalidade de parágrafo em uma variedade de idiomas de entrada. O valor padrão da propriedade TextReadingOrder foi alterado para DetectFromContent, para que o suporte para detecção da ordem de leitura seja habilitado por padrão. A propriedade TextReadingOrder também foi adicionada a TextBox, PasswordBox e RichEditBox. Você pode definir a propriedade TextAlignment em controles de texto para o novo valor de DetectFromContent para optar por ter o alinhamento detectado automaticamente a partir do conteúdo.
Renderização de texto | No Windows 10, o texto em aplicativos XAML agora é renderizado, na maioria das situações, em quase duas vezes a velocidade do Windows 8.1. Na maioria dos casos, os aplicativos se beneficiarão dessa melhoria sem qualquer alteração. Além da renderização mais rápida, essas melhorias também reduzem em 5% o consumo de memória típico de aplicativos XAML.

## <a name="application-model"></a>Modelo de aplicativo

Recurso | Descrição
 :---- | :----
Cortana | Amplie a funcionalidade básica da Cortana com comandos de voz que iniciam e executam uma única ação em um aplicativo externo. Ao integrar a funcionalidade básica do seu aplicativo e fornecer um ponto de entrada central para o usuário realizar a maioria das tarefas sem abrir o aplicativo diretamente, a Cortana pode atuar como uma ligação entre seu aplicativo e o usuário. Em muitos casos, isso pode economizar muito tempo e esforço do usuário. Saiba como [integrar seu aplicativo à tela da Cortana](https://docs.microsoft.com/previous-versions/windows/apps/dn974230(v=win.10)). Se você precisar de ideias, consulte as recomendações de design e as diretrizes de experiência do usuário específicas à Cortana em [Noções básicas de design para aplicativos Universais do Windows](https://docs.microsoft.com/windows/uwp/design/layout/index).
Explorador de Arquivos | Os novos métodos [Windows.System.Launcher.LaunchFolderAsync](https://docs.microsoft.com/uwp/api/windows.system.launcher.launchfolderasync) permitem que você inicie o Explorador de Arquivos e veja o conteúdo da pasta que você especificar.
Armazenamento compartilhado | A nova classe [Windows.ApplicationModel.DataTransfer.SharedStorageAccessManager](https://docs.microsoft.com/uwp/api/windows.applicationmodel.datatransfer.sharedstorageaccessmanager) e seus métodos permitem que você compartilhe um arquivo com outro aplicativo passando um token de compartilhamento ao iniciar o outro aplicativo usando a ativação de URI. O aplicativo de destino resgata o token para acessar o arquivo compartilhado pelo aplicativo de origem.
Configurações | Exiba páginas de configurações integradas usando o protocolo ms-settings com o método [LaunchUriAsync](https://docs.microsoft.com/uwp/api/windows.system.launcher.launchuriasync). Por exemplo, o código a seguir exibe a página de configurações de Wi-Fi: **bool result = await Launcher.LaunchUriAsync(new Uri("ms-settings://network/wifi"));** <br /><br />Para obter uma lista das páginas de configurações que você pode exibir, consulte [Como exibir páginas de configurações internas usando o protocolo ms-settings](https://docs.microsoft.com/previous-versions/windows/apps/jj207014(v=vs.105)).
Comunicação de aplicativo a aplicativo | As novas APIs de [comunicação de aplicativo a aplicativo](https://docs.microsoft.com/previous-versions/windows/apps/dn997827(v=win.10)) do Windows 10 permitem que aplicativos do Windows (bem como Windows Web apps) iniciem uns aos outros e troquem dados e arquivos. Usando essas novas APIs, tarefas complexas que exigiriam que o usuário usasse vários aplicativos podem agora ser executadas perfeitamente. Por exemplo, seu aplicativo pode iniciar um aplicativo de rede social para selecionar um contato ou iniciar um aplicativo de check-out para concluir um processo de pagamento.
Serviços de app | Um serviço de aplicativo é uma maneira de um aplicativo fornecer serviços a outros aplicativos no Windows 10. Um serviço de aplicativo assume a forma de tarefa em segundo plano. Os aplicativos em primeiro plano podem chamar um serviço de aplicativo em outro aplicativo para executar tarefas em segundo plano. Para obter informações de referência sobre a API de serviço de aplicativo, consulte [Windows.ApplicationModel.AppService](https://docs.microsoft.com/uwp/api/Windows.ApplicationModel.AppService).
Manifesto do pacote do aplicativo | As atualizações para a referência de [esquemas de manifesto de pacote](https://docs.microsoft.com/uwp/schemas/appxpackage/appx-package-manifest) para o Windows 10 incluem elementos que foram adicionados, removidos e alterados. Consulte [Hierarquia de elementos](https://docs.microsoft.com/uwp/schemas/appxpackage/uapmanifestschema/root-elements) para obter informações de referência sobre todos os elementos, atributos e tipos no esquema.

## <a name="devices"></a>Dispositivos

Recurso | Descrição
 :---- | :----
Microsoft Surface Hub | O Microsoft Surface Hub é um potente dispositivo de colaboração em equipe e uma plataforma de tela grande para aplicativos Universais do Windows que são executados nativamente a partir do Surface Hub ou de seu dispositivo conectado. Crie seus próprios aplicativos, projetados especificamente para sua empresa, que aproveitam as vantagens de tela grande, entrada por toque e à tinta e hardware onboard extensivo, como câmeras e sensores.<br /><br />Veja as recomendações de design e diretrizes de experiência do usuário específicas ao Surface Hub nas [Noções básicas de design para Aplicativos Universais do Windows](https://docs.microsoft.com/windows/uwp/design/layout/index). Esses documentos explicam técnicas de design responsivo para aplicativos Universais do Windows. <br /><br />Para obter detalhes sobre suporte a aplicativos públicos, consulte [SharedModeSettings](https://docs.microsoft.com/uwp/api/windows.system.profile.sharedmodesettings). Para saber mais sobre entrada à tinta e obter detalhes sobre suporte para escrita à tinta multiponto no novo controle [InkCanvas](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.inkcanvas), consulte [Windows.UI.Input.Inking](https://docs.microsoft.com/uwp/api/windows.ui.input.inking) e [Windows.UI.Input.Inking.Core](https://docs.microsoft.com/uwp/api/windows.ui.input.inking.core). Para manipular a entrada do sensor, confira [Integrando dispositivos, impressoras e sensores](https://docs.microsoft.com/previous-versions/windows/apps/br229563(v=win.10)).
Location | O Windows 10 apresenta um novo método para solicitar ao usuário permissão para acessar sua localização: [RequestAccessAsync](https://docs.microsoft.com/uwp/api/windows.devices.geolocation.geolocator.requestaccessasync). O usuário define a privacidade de seus dados de localização com as **configurações de privacidade de localização** no aplicativo **Configurações**. Seu aplicativo pode acessar a localização do usuário somente quando: A **Localização deste dispositivo** está ativada *(não aplicável ao Windows 10 para telefones)* , a configuração dos serviços de localização "**Localização**" está ativada e, em **Escolher aplicativos que podem usar sua localização**, seu aplicativo está definido como ativado. <br /><br />É importante chamar **RequestAccessAsync** antes de acessar a localização do usuário. Nesse momento, seu aplicativo deve estar em primeiro plano e **RequestAccessAsync** deve ser chamado do thread da interface do usuário. Até que o usuário conceda permissão para a localização a seu aplicativo, o aplicativo não pode acessar os dados de localização.
AllJoyn | O namespace [Windows.Devices.AllJoyn](https://docs.microsoft.com/uwp/api/windows.devices.alljoyn) do Windows Runtime do Windows apresenta a implementação da estrutura e serviços de software de código aberto AllJoyn da Microsoft. Essas APIs permitem que seu aplicativo de dispositivo Universal do Windows participe em cenários da Internet das Coisas (IoT) relacionados ao AllJoyn com outros dispositivos. Para obter mais detalhes sobre as APIs AllJoyn C, baixe a documentação da [The AllSeen Alliance](https://allseenalliance.org/). Use a ferramenta [AllJoynCodeGen](https://docs.microsoft.com/previous-versions/windows/apps/dn913809(v=win.10)) fornecida nesta versão para gerar um componente do Windows que você possa usar para permitir cenários com AllJoyn em seu aplicativo de dispositivo. <br /><br />**Observação:** Agora, o Windows 10 IoT Core está disponível para uma nova classe de dispositivos pequenos, permitindo que você crie dispositivos "IoT" (Internet das Coisas) usando o Windows e o Visual Studio. Saiba mais sobre o [Windows IoT no Centro de Desenvolvimento do Windows](https://developer.microsoft.com/windows/iot).
APIs de impressão em dispositivos móveis (XAML) | Há um conjunto unificado de APIs que permite imprimir conteúdo de seus aplicativos UWP baseados em XAML entre famílias de dispositivos, incluindo dispositivos móveis. Agora você pode adicionar impressão ao seu aplicativo móvel usando APIs de impressão conhecidas nos namespaces Windows.Graphics.Printing e Windows.UI.Xaml.Printing.
Bateria | As APIs de bateria no namespace [Windows.Devices.Power](https://docs.microsoft.com/uwp/api/windows.devices.power) permitem que seu aplicativo saiba mais sobre as baterias que estão conectadas ao dispositivo que está executando o aplicativo. Crie um objeto [Battery](https://docs.microsoft.com/uwp/api/windows.devices.power.battery) para representar um controlador de bateria individual ou uma agregação de todos os controladores de bateria (quando criado por [FromIdAsync](https://docs.microsoft.com/uwp/api/windows.devices.power.battery.fromidasync) ou [AggregateBattery](https://docs.microsoft.com/uwp/api/windows.devices.power.battery.aggregatebattery), respectivamente). Use o método [GetReport](https://docs.microsoft.com/uwp/api/windows.devices.power.battery.getreport) para retornar um objeto [BatteryReport](https://docs.microsoft.com/uwp/api/windows.devices.power.batteryreport) que indica a carga, a capacidade e o status das baterias correspondentes.
Dispositivos MIDI | O novo namespace [Windows.Devices.Midi](https://docs.microsoft.com/uwp/api/windows.devices.midi) permite que você crie A=aplicativos que podem se comunicar com dispositivos MIDI externos, aplicativos e dispositivos externos que se comunicam diretamente com o sintetizador de software Microsoft GS MIDI e cenários em que vários clientes acessam simultaneamente uma única porta MIDI.
Suporte para sensor personalizado | O namespace [Windows.Devices.Sensors.Custom](https://docs.microsoft.com/uwp/api/windows.devices.sensors.custom) permite que os desenvolvedores de hardware definam novos tipos de sensores personalizados, como um sensor de CO2.
Emulação de cartão com base em host (HCE) | A emulação de cartão host permite que você implemente serviços de emulação de cartão NFC hospedados no sistema operacional e ainda se comunique com o terminal do leitor externo via rádio NFC. Para disparar uma tarefa em segundo plano para emular um cartão inteligente via NFC, use a classe [SmartCardTrigger](https://docs.microsoft.com/uwp/api/Windows.ApplicationModel.Background.SmartCardTrigger). O valor de EmulatorHostApplicationActivated na enumeração [SmartCardTriggerType](https://docs.microsoft.com/uwp/api/Windows.Devices.SmartCards.SmartCardTriggerType) permite que seu aplicativo saiba que ocorreu um evento HCE.

## <a name="graphics"></a>Gráficos

Recurso | Descrição
 :---- | :----
DirectX | O DirectX 12 no Windows 10 apresenta a próxima versão do Microsoft Direct3D, a API gráfica 3D na base do DirectX. [Os elementos gráficos do Direct3D 12](https://docs.microsoft.com/windows/desktop/direct3d12/direct3d-12-graphics) oferecem a eficiência e o desempenho de uma API tipo console de baixo nível. O Direct3D 12 está mais rápido e mais eficiente do que nunca. Ele proporciona cenas mais detalhadas, mais objetos, efeitos mais complexos e o melhor uso de hardware de elementos gráficos modernos.
SoftwareBitmapSource | Em aplicativos Universais do Windows, você pode usar o novo tipo [SoftwareBitmapSource](https://docs.microsoft.com/uwp/api/windows.ui.xaml.media.imaging.softwarebitmapsource) como fonte de imagem XAML. Isso permite transmitir imagens descodificadas para a estrutura XAML ser exibida imediatamente na tela, ignorando a decodificação da imagem pela estrutura XAML. Você pode conseguir uma renderização de imagem muito mais rápida, como a renderização de fotos de baixa latência diretamente da câmera, usando decodificadores de imagem personalizados, capturando quadros de superfícies do DirectX ou até mesmo criando imagens na memória do zero e renderizando-as diretamente em XAML com baixa latência e sobrecarga de memória baixa.
Câmera de perspectiva | Em aplicativos Universais do Windows, o XAML tem uma nova API Transform3D que permite aplicar transformações de perspectiva a uma árvore (ou cena) XAML, que transforma todos os elementos filho XAML de acordo com essa única transformação de cena (ou câmera). Você podia fazer isso anteriormente usando MatrixTransform e cálculos complexos, mas o Transform3D simplifica esse efeito e também permite que o efeito seja animado. Para saber mais, confira a propriedade [UIElement.Transform3D](https://docs.microsoft.com/uwp/api/windows.ui.xaml.uielement.transform3d), [Transform3D](https://docs.microsoft.com/uwp/api/windows.ui.xaml.media.media3d.transform3d), [CompositeTransform3D](https://docs.microsoft.com/uwp/api/windows.ui.xaml.media.media3d.compositetransform3d) e [PerspectiveTransform3D](https://docs.microsoft.com/uwp/api/windows.ui.xaml.media.media3d.perspectivetransform3d).

## <a name="media"></a>Media

Recurso | Descrição
 :---- | :----
HTTP Live Streaming | Você pode usar a nova classe [AdaptiveMediaSource](https://docs.microsoft.com/uwp/api/windows.media.streaming.adaptive.adaptivemediasource) para adicionar recursos de streaming de vídeo adaptáveis aos seus aplicativos. O objeto é inicializado apontando-o para um arquivo de manifesto de streaming. Os formatos de manifesto com suporte incluem HLS (HTTP Live Streaming) e DASH (Dynamic Adaptive Streaming over HTTP). Depois que o objeto é vinculado a um elemento de mídia XAML, a reprodução adaptável é iniciada. As propriedades do fluxo, como as taxas de bits disponíveis, mínimas e máximas, podem ser consultadas e definidas quando apropriado.
Suporte para XVP (Transcode Video Processor) do Media Foundation para MFTs (Media Foundation Transforms) | Agora os aplicativos do Windows que usam MFTs (Media Foundation Transforms) podem usar o **XVP (Transcode Video Processor) do Media Foundation** para converter, dimensionar e transformar dados brutos de vídeo: O novo atributo [MF_XVP_CALLER_ALLOCATES_OUTPUT](https://docs.microsoft.com/windows/desktop/medfound/mf-xvp-caller-allocates-output) permite a saída para texturas alocadas pelo chamador mesmo no modo DXVA (Microsoft DirectX Video Acceleration). A nova interface [IMFVideoProcessorControl2](https://docs.microsoft.com/windows/desktop/api/mfidl/nn-mfidl-imfvideoprocessorcontrol2) permite que seu aplicativo habilite efeitos de hardware, consulte efeitos de hardware com suporte e substitua a operação de rotação realizada pelo processador de vídeo.
Transcodificação | A nova API [MediaProcessingTrigger](https://docs.microsoft.com/uwp/api/Windows.ApplicationModel.Background.MediaProcessingTrigger) permite que seu aplicativo execute a transcodificação de mídia em uma tarefa em segundo plano, para que suas operações de transcodificação possam continuar mesmo quando seu aplicativo em primeiro plano for encerrado.
Eventos de falha de mídia MediaElement | Em aplicativos Universais do Windows, o [MediaElement](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Controls.MediaElement) reproduzirá conteúdo com vários fluxos mesmo se houver um erro na decodificação de um dos fluxos, desde que o conteúdo da mídia tenha, no mínimo, um fluxo válido. Por exemplo, se o fluxo de vídeo em um conteúdo que tem um fluxo de áudio e vídeo falhar, o [MediaElement](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Controls.MediaElement) ainda reproduzirá o fluxo de áudio. O [PartialMediaFailureDetected](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.mediaelement.partialmediafailuredetected) avisa que um dos fluxos dentro de um fluxo não pôde ser decodificado. Ele também permite que você saiba que tipo de fluxo falhou para poder refletir essas informações na interface do usuário. Se todos os fluxos dentro de um fluxo de mídia falhar, o evento [MediaFailed](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.mediaelement.mediafailed) será lançado.
Suporte para transmissão de vídeo adaptável com MediaElement | [MediaElement](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Controls.MediaElement) tem o novo método [SetPlaybackSource](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.mediaelement.setplaybacksource) para oferecer suporte ao streaming de vídeo adaptável. Use esse método para definir sua fonte de mídia para um AdaptiveMediaSource.
Transmissão com MediaElement e Image | Os controles [MediaElement](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Controls.MediaElement) e Image têm o novo método [GetAsCastingSource](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.mediaelement.getascastingsource). Você pode usar esse método para enviar conteúdo de qualquer elemento de mídia ou imagem programaticamente para uma variedade maior de dispositivos remotos, como Miracast, Bluetooth e DLNA. Essa funcionalidade é habilitada automaticamente quando você define [AreTransportControlsEnabled](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.mediaelement.aretransportcontrolsenabled) como true em um MediaElement.
Controles de transporte de mídia para aplicativos de área de trabalho | A interface [ISystemMediaTransportControls](https://docs.microsoft.com/previous-versions/windows/desktop/mediatransport/isystemmediatransportcontrols) e as APIs relacionadas permitem que os aplicativos de área de trabalho interajam com os controles de transporte de mídia de sistema internos. Isso inclui responder às interações do usuário com os botões de controle de transporte e atualizar a exibição dos controles de transporte para mostrar metadados sobre reprodução atual de conteúdo de mídia.
Codificação e decodificação JPEG de acesso aleatório | Os novos métodos WIC [IWICJpegFrameEncode](https://docs.microsoft.com/windows/desktop/api/wincodec/nn-wincodec-iwicjpegframeencode) e [IWICJpegFrameDecode](https://docs.microsoft.com/windows/desktop/api/wincodec/nn-wincodec-iwicjpegframedecode) permitem a codificação e decodificação de imagens JPEG. Você agora também pode habilitar a indexação de dados de imagens, o que fornece acesso aleatório eficiente a imagens grandes graças ao volume de memória maior.
Sobreposições para composições de mídia | As novas APIs [MediaOverlay](https://docs.microsoft.com/uwp/api/Windows.Media.Editing.MediaOverlay) e [MediaOverlayLayer](https://docs.microsoft.com/uwp/api/Windows.Media.Editing.MediaOverlayLayer) facilitam adicionar várias camadas de conteúdo de mídia estático ou dinâmico a uma composição de mídia. Opacidade, posição e tempo podem ser ajustados para cada camada, e você ainda pode implementar seu próprio compositor personalizado para camadas de entrada.
Nova estrutura de efeitos | O namespace [Windows.Media.Effects](https://docs.microsoft.com/uwp/api/windows.media.effects) fornece uma estrutura simples e intuitiva para adicionar efeitos a fluxos de áudio e vídeo. A estrutura inclui interfaces básicas que você pode implementar para criar efeitos de vídeo e áudio personalizados e inseri-los no pipeline da mídia.

## <a name="networking"></a>Rede

Recurso | Descrição
 :---- | :----
Soquetes | As atualizações de soquete incluem: <br /><br />**Agente de soquete:** O agente de soquete pode estabelecer e encerrar conexões de soquete em nome de um aplicativo em qualquer estado do ciclo de vida do aplicativo. Isso torna os aplicativos e os serviços que eles fornecem mais detectáveis. Por exemplo, pelo agente de soquete, um serviço Win32 ainda pode aceitar conexões de soquete de entrada mesmo quando não estiver em execução. <br /><br />**Melhorias de produtividade:** a produtividade do soquete foi otimizada para aplicativos que usam o namespace Windows.Networking.Sockets.
Tarefas pós-processamento de transferência em segundo plano | As novas APIs do namespace [Windows.Networking.BackgroundTransfer](https://docs.microsoft.com/uwp/api/windows.networking.backgroundtransfer) permitem que você registre grupos de tarefas de pós-processamento. Dessa forma, seu aplicativo pode agir de acordo com o sucesso ou a falha das transferências em segundo plano imediatamente, mesmo não estando em primeiro plano, em vez de aguardar até a próxima vez em que o usuário retomar o aplicativo.
Suporte a Bluetooth para anúncios | Com o namespace [Windows.Devices.Bluetooth.Advertisement](https://docs.microsoft.com/uwp/api/windows.devices.bluetooth.advertisement), seus aplicativos podem enviar, receber e filtrar anúncios Bluetooth LE.
Atualização da API do Wi-Fi Direct | O agente de dispositivo está atualizado para habilitar o emparelhamento com dispositivos sem sair do aplicativo. Adições ao namespace [Windows.Devices.WiFiDirect](https://docs.microsoft.com/uwp/api/windows.devices.wifidirect) também permitem que um dispositivo torne-se detectável por outros dispositivos e permitem que ele escute as notificações de conexão de entrada.<br /><br />**Observação:** Nesta versão, as melhorias do recurso Wi-Fi Direct não são incorporadas à experiência do usuário e oferecem suporte apenas ao emparelhamento com o pressionar de um botão. Além disso, essa versão oferece suporte apenas a uma conexão ativa.
Melhorias do suporte para JSON | Agora o namespace [Windows.Data.Json](https://docs.microsoft.com/uwp/api/windows.data.json) oferece melhor suporte às definições padrão existentes e à experiência do desenvolvedor ao converter objetos JSON durante sessões de depuração.

## <a name="security"></a>Segurança

Recurso | Descrição
 :---- | :----
Criptografia ECC | As novas APIs no namespace [Windows.Security.Cryptography](https://docs.microsoft.com/uwp/api/windows.security.cryptography) oferecem suporte à criptografia ECC (Elliptical Curve Cryptography), uma implementação de criptografia de chave pública com base em curvas elípticas sobre campos finitos. A ECC é matematicamente mais complexa que a RSA, fornece tamanhos de chave menores, reduz o consumo de memória e melhora o desempenho. Ela oferece a clientes e serviços Microsoft uma alternativa para chaves RSA e parâmetros de curva NIST aprovados.
Microsoft Passport | Microsoft Passport é um método alternativo de autenticação que substitui as senhas por criptografia assimétrica e um gesto. As classes no namespace Credentials, como [KeyCredentialManger](https://docs.microsoft.com/uwp/api/windows.security.credentials.keycredentialmanager), tornam mais fácil para os desenvolvedores criarem aplicativos usando o Microsoft Passport sem a complexidade da criptografia ou biometria.
Microsoft Passport for Work | Microsoft Passport for Work é um método alternativo para entrar no Windows usando sua conta do Active Directory do Azure que não usa senhas, cartões inteligentes físicos e virtuais. Você pode optar por habilitar ou desabilitar essa configuração de política.
Token Broker | O Token Broker é uma nova estrutura de autenticação que torna mais fácil para os aplicativos se conectarem a provedores de identidade online (como o Facebook). Recursos como gerenciamento de nome de usuário e senha da conta e uma interface do usuário simplificada oferecem uma experiência de autenticação aprimorada para os usuários.

## <a name="system-services"></a>Serviços do sistema

Recurso | Descrição
 :---- | :----
Potência | Seu aplicativo da área de trabalho do Windows agora pode ser notificado quando a economia de bateria estiver ativada ou desativada. Respondendo às mudanças nas condições de energia, seu aplicativo tem a oportunidade de ajudar a estender a duração da bateria. <br /><br />[GUID_POWER_SAVING_STATUS](https://docs.microsoft.com/windows/desktop/Power/power-setting-guids): use esse novo GUID com a função [PowerSettingRegisterNotification](https://docs.microsoft.com/windows/desktop/api/powersetting/nf-powersetting-powersettingregisternotification) para ser notificado quando a economia de bateria estiver ativada ou desativada. <br /><br />[SYSTEM_POWER_STATUS](https://docs.microsoft.com/windows/desktop/api/winbase/ns-winbase-_system_power_status): essa estrutura foi atualizada para oferecer suporte à economia de bateria. O quarto membro, *SystemStatusFlag* (anteriormente chamado Reserved1), agora indica se a economia de bateria está ativada ou não. Use a função [GetSystemPowerStatus](https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-getsystempowerstatus) para recuperar um ponteiro para essa estrutura.
Versão | Você pode usar as [funções auxiliares de versão](https://docs.microsoft.com/windows/desktop/SysInfo/version-helper-apis) para determinar a versão do sistema operacional. Para o Windows 10, essas funções auxiliares incluem uma nova função, [IsWindows10OrGreater](https://docs.microsoft.com/windows/desktop/api/versionhelpers/nf-versionhelpers-iswindows10orgreater). Você deve usar as funções auxiliares em vez das funções preteridas [GetVersionEx](https://docs.microsoft.com/windows/desktop/api/sysinfoapi/nf-sysinfoapi-getversionexa) e [GetVersion](https://docs.microsoft.com/windows/desktop/api/sysinfoapi/nf-sysinfoapi-getversion) quando quiser determinar a versão do sistema. Para obter mais informações sobre como obter a versão do sistema, consulte [Obtendo a versão do sistema](https://docs.microsoft.com/windows/desktop/SysInfo/getting-the-system-version). <br /><br />Se você usar a função preterida [GetVersionEx](https://docs.microsoft.com/windows/desktop/api/sysinfoapi/nf-sysinfoapi-getversionexa) ou [GetVersion](https://docs.microsoft.com/windows/desktop/api/sysinfoapi/nf-sysinfoapi-getversion) para obter informações de versão em uma estrutura [OSVERSIONINFOEX](https://docs.microsoft.com/windows/desktop/api/winnt/ns-winnt-_osversioninfoexa) ou [OSVERSIONINFO](https://docs.microsoft.com/windows/desktop/api/winnt/ns-winnt-_osversioninfoa), lembre-se de que o número da versão que essas estruturas contêm aumenta de 6.3, para o Windows 8.1 e o Windows Server 2012 R2, para 10.0, para o Windows 10. Para obter mais informações sobre números de versão do sistema operacional, consulte [Versão do sistema operacional](https://docs.microsoft.com/windows/desktop/SysInfo/operating-system-version). <br /><br />Você também precisa direcionar seu aplicativo especificamente para o Windows 8.1 ou Windows 10 para obter as informações de versão corretas para essas versões com a função [GetVersionEx](https://docs.microsoft.com/windows/desktop/api/sysinfoapi/nf-sysinfoapi-getversionexa) ou [GetVersion](https://docs.microsoft.com/windows/desktop/api/sysinfoapi/nf-sysinfoapi-getversion). Para obter informações sobre como direcionar seu aplicativo para essas versões do Windows, consulte [Direcionando seu aplicativo para o Windows](https://docs.microsoft.com/windows/desktop/SysInfo/targeting-your-application-at-windows-8-1).
Informações do usuário | Novas APIs no namespace [Windows.System](https://docs.microsoft.com/uwp/api/windows.system) facilitam o acesso a informações sobre um usuário, como seu nome de usuário e imagem da conta. Também fornecem a capacidade de responder a eventos do usuário, como logon e logoff.
Gerenciamento de memória e criação de perfil | O suporte à API de criação de perfil de memória [Windows.System](https://docs.microsoft.com/uwp/api/windows.system) foi estendido a todas as plataformas, e sua funcionalidade geral foi aprimorada com novas classes e funções.

## <a name="storage"></a>Armazenamento

Recurso | Descrição
 :---- | :----
APIs de pesquisa de arquivo disponíveis para o Windows Phone | Como fornecedor de aplicativos, você pode registrar seu aplicativo para compartilhar uma pasta de armazenamento com outros aplicativos que publica. Basta adicionar extensões no manifesto do aplicativo. Em seguida, chame o método [Windows.Storage.ApplicationData.GetPublisherCacheFolder](https://docs.microsoft.com/uwp/api/windows.storage.applicationdata.getpublishercachefolder) para obter o local de armazenamento compartilhado. O modelo de segurança forte dos aplicativos do Windows Runtime normalmente impede que aplicativos compartilhem dados entre si. Mas pode ser útil para aplicativos do mesmo fornecedor compartilharem arquivos e configurações por usuário.

## <a name="tools"></a>Ferramentas

Recurso | Descrição
 :---- | :----
Árvore Visual Dinâmica no Visual Studio | O Visual Studio tem um novo recurso Árvore Visual Dinâmica. Você pode usá-lo durante a depuração para saber rapidamente o estado da árvore visual de seu aplicativo e descobrir como as propriedades dos elementos foram definidas. Ele também permite alterar os valores de propriedade enquanto seu aplicativo está em execução, para que você possa ajustar e experimentar sem precisar abrir novamente.
Log de rastreamento | [TraceLogging](https://docs.microsoft.com/windows/desktop/tracelogging/trace-logging-portal) é uma nova API de rastreamento de eventos para aplicativos de modo de usuário e drivers de modo kernel; ela é baseada no ETW ([Rastreamento de Eventos para Windows](https://docs.microsoft.com/windows/desktop/ETW/event-tracing-portal)). Essa API oferece uma maneira simplificada de instrumentar código e incluir dados estruturados com eventos sem a necessidade de um arquivo XML de manifesto de instrumentação separado. As APIs WinRT, .NET e C/C++ TraceLogging estão disponíveis para atender a diferentes públicos de desenvolvedores.

## <a name="user-experience"></a>Experiência de usuário

Recurso | Descrição
 :---- | :----
Reconhecimento de fala | O reconhecimento de fala contínua para cenários de ditados longos agora é compatível com a Plataforma Universal do Windows. Veja como habilitar o ditado contínuo nos documentos de interação de fala.
Recursos de arrastar e soltar entre plataformas de aplicativos diferentes | Os novos namespaces [Windows.ApplicationModel.DataTransfer.DragDrop](https://docs.microsoft.com/uwp/api/windows.applicationmodel.datatransfer.dragdrop) levam a funcionalidade de arrastar e soltar para aplicativos Universais do Windows. Anteriormente, os cenários comuns de arrastar e soltar de programas de área de trabalho — como arrastar um documento de uma pasta para uma mensagem de email do Outlook para anexá-lo — não são possíveis com aplicativos Universais do Windows. Usando essas novas APIs, seu aplicativo pode permitir que os usuários movam dados facilmente entre diferentes aplicativos Universais do Windows e a área de trabalho. <br /><br />Para oferecer suporte para arrastar e soltar entre aplicativos, estas novas APIs foram adicionadas ao XAML: [ListViewBase.DragItemsCompleted](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.listviewbase.dragitemscompleted); <br />UIElement: [CanDrag](https://docs.microsoft.com/uwp/api/windows.ui.xaml.uielement.candrag), [DragStarting](https://docs.microsoft.com/uwp/api/windows.ui.xaml.uielement.dragstarting), [StartDragAsync](https://docs.microsoft.com/uwp/api/windows.ui.xaml.uielement.startdragasync), [DropCompleted](https://docs.microsoft.com/uwp/api/windows.ui.xaml.uielement.dropcompleted);  <br />[DragOperationDeferral](https://docs.microsoft.com/uwp/api/windows.ui.xaml.dragoperationdeferral), [DragUI](https://docs.microsoft.com/uwp/api/windows.ui.xaml.dragui), [DragUIOverride](https://docs.microsoft.com/uwp/api/windows.ui.xaml.draguioverride); <br />DragEventArgs: [AcceptedOperation](https://docs.microsoft.com/uwp/api/windows.ui.xaml.drageventargs.acceptedoperation), [DataView](https://docs.microsoft.com/uwp/api/windows.ui.xaml.drageventargs.dataview), [DragUIOverride](https://docs.microsoft.com/uwp/api/windows.ui.xaml.drageventargs.draguioverride), [GetDeferral](https://docs.microsoft.com/uwp/api/windows.ui.xaml.drageventargs.getdeferral), [Modifiers](https://docs.microsoft.com/uwp/api/windows.ui.xaml.drageventargs.modifiers); <br />[DragItemsCompletedEventArgs](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.dragitemscompletedeventargs), [DropCompletedEventArgs](https://docs.microsoft.com/uwp/api/windows.ui.xaml.dropcompletedeventargs), [DragStartingEventArgs](https://docs.microsoft.com/uwp/api/windows.ui.xaml.dragstartingeventargs)
Barras de título de janela personalizadas | Para aplicativos UWP para a família de dispositivos de desktop, agora você pode usar a classe [ApplicationViewTitleBar](https://docs.microsoft.com/uwp/api/windows.ui.viewmanagement.applicationviewtitlebar) com a propriedade [ApplicationView.TitleBar](https://docs.microsoft.com/uwp/api/windows.ui.viewmanagement.applicationview.titlebar) e o método [Window.SetTitleBar](https://docs.microsoft.com/uwp/api/windows.ui.viewmanagement.applicationview.titlebar) para substituir o conteúdo da barra de título padrão do Windows por seu próprio conteúdo XAML personalizado. O XAML é tratado como "cromo do sistema", para que o Windows manipule os eventos de entrada em vez de seu aplicativo. Isso significa que o usuário ainda pode arrastar e redimensionar a janela, mesmo ao clicar no conteúdo da barra de título personalizada.

## <a name="web"></a>Web

Recurso | Descrição
 :---- | :----
Microsoft Edge | O Microsoft Edge é o novo navegador padrão criado para o Windows 10. Para saber mais e ter uma visão geral dos recursos e padrões de desenvolvedor incluídos no Microsoft Edge, inclusive os últimos recursos de JavaScript, consulte o [Guia de Desenvolvedor do Microsoft Edge](https://developer.microsoft.com/microsoft-edge/platform/documentation/dev-guide).
Navegação no WebView | O controle [WebView](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.webview) usa o mesmo mecanismo de renderização do novo navegador Microsoft Edge. Isso fornece o modo de renderização de HTML mais preciso e compatível com padrões.
WebView fora do thread | Você pode especificar um [WebView.ExecutionMode](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.webview.executionmode) para habilitar o processamento e a exibição de conteúdo da Web em um thread separado em segundo plano. Isso pode melhorar o desempenho em cenários específicos.
Evento WebView.UnsupportedUriSchemeIdentified | O novo evento [WebView.UnsupportedUriSchemeIdentified](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.webview.unsupportedurischemeidentified) permite que você decida como seu aplicativo deve lidar com um esquema de URI sem suporte. Você pode manipular esse evento para permitir que seu aplicativo forneça tratamento personalizado a esquemas de URI sem suporte. Para o controle HTML WebView, veja o evento [MSWebViewUnsupportedUriSchemeIdentified](https://docs.microsoft.com/previous-versions/windows/apps/dn803906(v=win.10)).
Evento WebView.NewWindowRequested | O novo evento [WebView.NewWindowRequested](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.webview.newwindowrequested) permite que você responda quando um script em um WebView solicita uma nova janela do navegador. Para o controle HTML WebView, veja o evento [MSWebViewNewWindowRequested](https://docs.microsoft.com/microsoft-edge/webview).
Evento WebView.PermissionRequested | O novo evento [WebView.PermissionRequested](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.webview.permissionrequested) permite que o conteúdo do WebView use as novas APIs HTML5 avançadas que exigem permissão especial do usuário, como localização geográfica. Para o controle HTML WebView, veja o evento [MSWebViewPermissionRequested](https://docs.microsoft.com/previous-versions/windows/apps/dn806030(v=win.10)).
Evento WebView.UnviewableContentIdentified | O novo evento [WebView.UnviewableContentIdentified](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.webview.unviewablecontentidentified) permite que você responda quando o WebView for navegado para conteúdo não Web, como um arquivo PDF ou documento do Office. Para controles HTML WebView, consulte o evento [MSWebViewUnviewableContentIdentified](https://docs.microsoft.com/microsoft-edge/webview).
Método WebView.AddWebAllowedObject | Você pode chamar o novo método [WebView.AddWebAllowedObject](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.webview.addweballowedobject) para injetar um objeto WinRT em um WebView XAML e, em seguida, chamar suas funções a partir de um JavaScript hospedado nesse WebView. Por exemplo, o conteúdo da Web pode mostrar notificações do sistema solicitando que seu aplicativo pai chame a API WinRT [ToastNotificationManager](https://docs.microsoft.com/uwp/api/windows.ui.notifications.toastnotificationmanager). Para o controle HTML WebView, consulte o método [addWebAllowedObject](https://docs.microsoft.com/microsoft-edge/webview).
Método WebView.ClearTemporaryWebDataAsync | Quando um usuário interage com o conteúdo da Web em um XAML WebView, o controle WebView armazena dados em cache com base na sessão do usuário. Você pode chamar o novo método [ClearTemporaryWebDataAsync](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.webview.cleartemporarywebdataasync) para limpar esse cache. Por exemplo, você pode limpar o cache quando um usuário sai do aplicativo para que outro usuário não possa acessar os dados da sessão anterior.
