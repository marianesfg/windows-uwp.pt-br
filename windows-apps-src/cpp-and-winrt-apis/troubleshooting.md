---
description: A tabela de sintomas de solução de problemas e soluções neste tópico pode ser útil se você estiver recortando um novo código ou fazendo a portabilidade de um app existente.
title: Solucionando problemas de C++/WinRT
ms.date: 05/07/2018
ms.topic: article
keywords: windows 10, uwp, padrão, c++, cpp, winrt, projeção, solução de problemas, HRESULT, erro
ms.localizationpriority: medium
ms.openlocfilehash: 120d5c8014ce9ac3cab9b2dfb1d778173f2434c4
ms.sourcegitcommit: 231065c899d0de285584d41e6335251e0c2c4048
ms.translationtype: MT
ms.contentlocale: pt-BR
ms.lasthandoff: 12/10/2018
ms.locfileid: "8825562"
---
# <a name="troubleshooting-cwinrt-issues"></a>Solucionando problemas de C++/WinRT

> [!NOTE]
> Para obter informações sobre como instalar e usar o [C++ c++ WinRT](/windows/uwp/cpp-and-winrt-apis/intro-to-using-cpp-with-winrt) Visual Studio Extension (VSIX) (que oferece suporte ao modelo de projeto, bem como C++ c++ WinRT MSBuild propriedades e destinos) consulte [suporte do Visual Studio para C++ c++ WinRT e o VSIX](intro-to-using-cpp-with-winrt.md#visual-studio-support-for-cwinrt-and-the-vsix).

Este tópico é fornecido como precaução para que você fique atento a ele imediatamente, mesmo que você ainda não esteja precisando dessas informações. A tabela de sintomas de solução de problemas e soluções a seguir pode ser útil se você estiver recortando um novo código ou fazendo a portabilidade de um app existente. Se você estiver fazendo a portabilidade e estiver ansioso para avançar e chegar ao estágio de compilação e execução do projeto, poderá fazer um progresso temporário comentando ou eliminando qualquer código não essencial que esteja causando problemas e retornando para resolver esse problema mais tarde.

Para obter uma lista de perguntas frequentes, consulte as [Perguntas frequentes](faq.md).

## <a name="tracking-down-xaml-issues"></a>Rastreando problemas de XAML
Pode ser difícil diagnosticar exceções de análise XAML, especialmente se não houver mensagens de erro significativas na exceção. Certifique-se de que o depurador esteja configurado para capturar exceções de primeira chance (para tentar e capturar a exceção de análise logo no início). Você pode inspecionar a variável de exceção no depurador para determinar se o HRESULT ou a mensagem tem informações úteis. Além disso, verifique na janela de saída do Visual Studio se há mensagens de erro de saída do analisador XAML.

Se o app for encerrado e tudo o que você sabe é que uma exceção sem tratamento foi lançada durante a análise da marcação XAML, isso pode ser resultado de uma referência (por chave) a um recurso ausente. Ou talvez essa exceção tenha sido lançada em um UserControl, controle personalizado ou painel de layout personalizado. Um último recurso é uma divisão binária. Remova cerca da metade da marcação de uma página XAML e execute o app novamente. Em seguida, você saberá se o erro está em algum lugar dentro da metade removida (que agora você deverá restaurar em qualquer caso) ou na metade que você não removeu. Repita o processo dividindo a metade que contém o erro e assim por diante, até zerar o problema.

## <a name="symptoms-and-remedies"></a>Sintomas e soluções
| Sintoma | Solução |
|---------|--------|
| Uma exceção é lançada em tempo de execução com um valor HRESULT de REGDB_E_CLASSNOTREGISTERED. | Uma das causas deste erro é que o componente do Tempo de Execução do Windows não pode ser carregado. Verifique se o arquivo de metadados do Windows Runtime do componente (`.winmd`) tem o mesmo nome do binário de componente (o `.dll`), que também é o nome do projeto e o nome do namespace raiz. Além disso, verifique se os metadados do Windows Runtime e o binário foram copiados corretamente pelo processo de compilação para a pasta `Appx` do app de consumo. Confirme se o `AppxManifest.xml` do app de consumo (também na pasta `Appx`) contém um elemento **&lt;InProcessServer&gt;** que está declarando corretamente a classe ativável e o nome binário. Esse erro também poderá ocorrer se você instanciar uma classe de tempo de execução localmente implementada por meio do construtor padrão do tipo projetado. Consulte [Controles XAML; associar a uma propriedade C++/WinRT](binding-property.md) para obter mais informações sobre como usar corretamente o tipo projetado nesse caso. |
| O compilador C++ gera o erro "*'implements_type': is not a member of any direct or indirect base class of '&lt;projected type&gt;'*". | Isso poderá acontecer quando você chamar **make** com o nome não qualificado de namespace do tipo de implementação (**MyRuntimeClass**, por exemplo) e não tiver incluído o cabeçalho desse tipo. O compilador interpreta **MyRuntimeClass** como o tipo projetado. A solução é incluir o cabeçalho do tipo de implementação (`MyRuntimeClass.h`, por exemplo). |
| O compilador C++ gera o erro "*attempting to reference a deleted function*". | Isso poderá acontecer quando você chamar **make** e o tipo de implementação passado como parâmetro de modelo tiver um construtor padrão `= delete`. Edite o arquivo de cabeçalho do tipo de implementação e altere `= delete` para `= default`. Você também pode adicionar um construtor em IDL para a classe de tempo de execução. |
| Você implementou [**INotifyPropertyChanged**](/uwp/api/windows.ui.xaml.data.inotifypropertychanged), mas suas associações XAML não estão sendo atualizadas (e a interface do usuário não está assinando [**PropertyChanged**](/uwp/api/windows.ui.xaml.data.inotifypropertychanged.PropertyChanged)). | Lembre-se de definir `Mode=OneWay` (ou TwoWay) em sua expressão de associação na marcação XAML. Consulte [Controles XAML; associar a uma propriedade C++/WinRT](binding-property.md). |
| Você está associando um controle de itens XAML a uma coleção observável, e uma exceção é lançada em tempo de execução com a mensagem "The parameter is incorrect". | No IDL e na implementação, declare qualquer coleção observável como tipo **Windows.Foundation.Collections.IVector<IInspectable>**. Mas retorne um objeto que implementa **Windows.Foundation.Collections.IObservableVector<T>**, em que T é o tipo de elemento. Consulte [Controles de itens XAML; associar a uma coleção C++/WinRT](binding-collection.md).  |
| O compilador C++ gera um erro do formulário "*'MyImplementationType_base&lt;MyImplementationType&gt;': no appropriate default constructor available*".|Isso poderá acontecer quando você fizer a derivação de um tipo que tem um construtor não trivial. O construtor do tipo derivado precisa passar os parâmetros que o construtor do tipo base precisa. Para obter um exemplo trabalhado, consulte [Fazendo a derivação de um tipo que tem um construtor não trivial](author-apis.md#deriving-from-a-type-that-has-a-non-default-constructor).|
| O compilador C++ gera o erro "*cannot convert from 'const std::vector&lt;std::wstring,std::allocator&lt;_Ty&gt;&gt;' to 'const winrt::param::async_iterable&lt;winrt::hstring&gt; &'*".|Isso poderá acontecer quando você passar um std::vector de std::wstring para uma API do Windows Runtime que espera uma coleção. Para obter mais informações, consulte [Tipos de dados C++ padrão e C++/WinRT](std-cpp-data-types.md).|
| O compilador C++ gera o erro "*cannot convert from 'const std::vector&lt;winrt::hstring,std::allocator&lt;_Ty&gt;&gt;' to 'const winrt::param::async_iterable&lt;winrt::hstring&gt; &'*".|Isso poderá acontecer quando você passar um std::vector de winrt::hstring para uma API assíncrona do Windows Runtime que espera uma coleção e não tiver copiado nem movido o vetor para o computador chamado assíncrono. Para obter mais informações, consulte [Tipos de dados C++ padrão e C++/WinRT](std-cpp-data-types.md).|
| Ao abrir um projeto, o Visual Studio gera o erro "*The application for the project is not installed*".|Se você ainda não tiver instalado **Windows Universal tools for C++ development** na caixa de diálogo **New Project**, precisará fazê-lo. Se isso não resolver o problema, possivelmente o projeto dependerá da Extensão do Visual Studio (VSIX) do C++/WinRT (consulte [Suporte do Visual Studio para C++/WinRT e o VSIX](intro-to-using-cpp-with-winrt.md#visual-studio-support-for-cwinrt-and-the-vsix)).|
| Os testes do Kit de Certificação de Aplicativos Windows produzem um erro informando que uma das suas classes de tempo de execução "*does not derive from a Windows base class. All composable classes must ultimately derive from a type in the Windows namespace*".|Qualquer classe de tempo de execução (que você declara em seu aplicativo) que deriva de uma classe base é conhecido como um *composable* classe. A classe base definitiva de uma classe composable deve ser um tipo originando do namespace; Por exemplo, [**DependencyObject**](/uwp/api/windows.ui.xaml.dependencyobject). Consulte [controles XAML; associar a C++ c++ WinRT propriedade](binding-property.md) para obter mais detalhes.|
| O compilador C++ gera o erro "*must be WinRT type*" para uma especialização de delegação de EventHandler ou TypedEventHandler.|Em vez disso, é recomendável o uso de **winrt::delegate&lt;...T&gt;**. Consulte [Criar eventos em C++/WinRT](author-events.md).|
| O compilador C++ gera o erro "*must be WinRT type*" para uma especialização de operação assíncrona do Windows Runtime.|É recomendável retornar uma [**tarefa**](https://msdn.microsoft.com/library/hh750113) PPL (Parallel Patterns Library). Consulte [Simultaneidade e operações assíncronas](concurrency.md).|
| O compilador C++ gera "*error C2220: warning treated as error - no 'object' file generated*".|Corrija o aviso ou defina **C/C++**>**Geral**>**Tratar avisos como erros** **não (/ /WX-)**.|
| O app falha porque um manipulador de eventos no objeto C++/WinRT é chamado depois que o objeto é destruído.|Consulte [Acessando com segurança o *esse* ponteiro com um representante do manipulador de eventos](weak-references.md#safely-accessing-the-this-pointer-with-an-event-handling-delegate).|
| O compilador C++ gera "*error C2338: This is only for weak ref support*".|Você está solicitando uma referência fraca para um tipo que passou o struct de marcador **winrt::no_weak_ref** como um argumento de modelo para sua classe base. Consulte [recusando o suporte a referência fraca](weak-references.md#opting-out-of-weak-reference-support).|
| O vinculador C++ produz "*error LNK2019: símbolo externo*"|Consulte [por que é o vinculador me dar um "LNK2019: símbolo externo" Erro?](faq.md#why-is-the-linker-giving-me-a-lnk2019-unresolved-external-symbol-error).|
| A cadeia de ferramentas LLVM e Clang produz erros quando usado com C++ c++ WinRT.|Não oferecemos suporte a cadeia de ferramentas LLVM e Clang para C++ c++ WinRT, mas se você quisesse emular como podemos usá-lo internamente, em seguida, você poderia tentar um experimento, como o descrito em [pode usar LLVM/Clang para compilar com C++ c++ WinRT?](faq.md#can-i-use-llvmclang-to-compile-with-cwinrt).|
| O compilador C++ gera "*Nenhum construtor padrão apropriado disponível*" para um tipo projetado. | Se você está tentando para atrasar a inicialização de um objeto de classe de tempo de execução, ou consumir e implementar uma classe de tempo de execução no mesmo projeto e, em seguida, você precisará chamar o `nullptr_t` construtor. Para obter mais informações, consulte [Consumir APIs com C++/WinRT](consume-apis.md). |
| O compilador C++ gera "*erro C3861: 'from_abi': identificador não encontrado*" e outros erros que se originam no *base.h*. Você poderá ver esse erro, se você estiver usando o Visual Studio 2017 (versão 15.8.0 ou superior) e o SDK do Windows versão 10.0.17134.0 (Windows 10, versão 1803) de direcionamento. | Qualquer um direcionar uma posterior (mais compatível) versão do SDK do Windows, ou conjunto de propriedade do projeto **C/C++** > **idioma** > **modo de conformidade: não** (Além disso, se **/ permissivo-** aparece na propriedade do projeto **C/C++**  >  **Idioma** > **linha de comando** em **Opções adicionais**, exclua-o). |
| O compilador C++ gera "*erro C2039: 'IUnknown': não é um membro de ' \'global namespace '*". | Consulte [como redirecionar C++ c++ WinRT projeto para uma versão posterior do SDK do Windows](news.md#how-to-retarget-your-cwinrt-project-to-a-later-version-of-the-windows-sdk). |
| O vinculador C++ produz "*error LNK2019: símbolo externo _WINRT_CanUnloadNow@0 referenciado na função _VSDesignerCanUnloadNow@0 *" | Consulte [como redirecionar C++ c++ WinRT projeto para uma versão posterior do SDK do Windows](news.md#how-to-retarget-your-cwinrt-project-to-a-later-version-of-the-windows-sdk). |

> [!NOTE]
> Se este tópico não responder à sua pergunta, você pode encontrar ajuda visitando a [comunidade de desenvolvedores do Visual Studio C++](https://developercommunity.visualstudio.com/spaces/62/index.html), ou usando o [ `c++-winrt` marca no Stack Overflow](https://stackoverflow.com/questions/tagged/c%2b%2b-winrt).
