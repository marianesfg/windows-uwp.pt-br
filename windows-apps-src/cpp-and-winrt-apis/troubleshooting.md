---
description: A tabela de sintomas de solução de problemas e soluções neste tópico pode ser útil para você se você estiver recortando novo código ou fazendo a portabilidade de um aplicativo existente.
title: Como solucionar problemas de C++/WinRT
ms.date: 04/23/2019
ms.topic: article
keywords: windows 10, uwp, padrão, c++, cpp, winrt, projeção, solução de problemas, HRESULT, erro
ms.localizationpriority: medium
ms.openlocfilehash: add3875e15ad747422b2e53e5d8f8438b61b3b20
ms.sourcegitcommit: d37a543cfd7b449116320ccfee46a95ece4c1887
ms.translationtype: HT
ms.contentlocale: pt-BR
ms.lasthandoff: 07/16/2019
ms.locfileid: "68270098"
---
# <a name="troubleshooting-cwinrt-issues"></a>Como solucionar problemas de C++/WinRT

> [!NOTE]
> Para saber mais sobre como instalar e usar a Extensão do Visual Studio (VSIX) para [C++/WinRT](/windows/uwp/cpp-and-winrt-apis/intro-to-using-cpp-with-winrt) (que fornece suporte de modelo de projeto), confira [Suporte do Visual Studio para C++/WinRT](intro-to-using-cpp-with-winrt.md#visual-studio-support-for-cwinrt-xaml-the-vsix-extension-and-the-nuget-package).

Este tópico é fornecido como precaução para que você fique atento a ele imediatamente, mesmo que você ainda não esteja precisando dessas informações. A tabela de sintomas de solução de problemas e soluções a seguir pode ser útil se você estiver recortando um novo código ou fazendo a portabilidade de um aplicativo existente. Se você estiver fazendo a portabilidade e estiver ansioso para avançar e chegar ao estágio de compilação e execução do projeto, poderá fazer um progresso temporário comentando ou eliminando qualquer código não essencial que esteja causando problemas e retornando para resolver esse problema mais tarde.

Para obter a lista de perguntas frequentes, confira [Perguntas frequentes](faq.md).

## <a name="tracking-down-xaml-issues"></a>Como rastrear problemas de XAML
Pode ser difícil diagnosticar&mdash;exceções de análise XAML, especialmente se não houver mensagens de erro significativas na exceção. Certifique-se de que o depurador esteja configurado para capturar exceções de primeira chance (para tentar e capturar a exceção de análise logo no início). Você pode inspecionar a variável de exceção no depurador para determinar se o HRESULT ou a mensagem tem informações úteis. Além disso, verifique na janela de saída do Visual Studio se há mensagens de erro de saída do analisador XAML.

Se o aplicativo for encerrado e tudo o que você sabe é que uma exceção sem tratamento foi lançada durante a análise da marcação XAML, isso pode ser resultado de uma referência (por chave) a um recurso ausente. Ou ela pode ser uma exceção lançada dentro de um UserControl, um controle personalizado ou um painel de layout personalizado. Um último recurso é uma divisão binária. Remova cerca da metade da marcação de uma página XAML e execute o aplicativo novamente. Em seguida, você saberá se o erro está em algum lugar dentro da metade removida (que agora você deverá restaurar em qualquer caso) ou na metade que você não removeu. Repita o processo dividindo a metade que contém o erro e assim por diante, até zerar o problema.

## <a name="symptoms-and-remedies"></a>Sintomas e soluções
| Sintoma | Solução |
|---------|--------|
| Uma exceção é lançada em tempo de execução com um valor HRESULT de REGDB_E_CLASSNOTREGISTERED. | Confira [Por que estou recebendo uma exceção de "classe não registrada"?](faq.md#why-am-i-getting-a-class-not-registered-exception). |
| O compilador C++ gera o erro " *'implements_type': não é membro de qualquer classe base direta ou indireta de '&lt;tipo projetado&gt;'* ". | Isso poderá acontecer quando você chamar **make** com o nome não qualificado de namespace do tipo de implementação (**MyRuntimeClass**, por exemplo) e não tiver incluído o cabeçalho desse tipo. O compilador interpreta **MyRuntimeClass** como o tipo projetado. A solução é incluir o cabeçalho do tipo de implementação (`MyRuntimeClass.h`, por exemplo). |
| O compilador C++ gera o erro "*tentando referenciar uma função excluída*". | Isso poderá acontecer quando você chamar **make** e o tipo de implementação passado como parâmetro de modelo tiver um construtor padrão `= delete`. Edite o arquivo de cabeçalho do tipo de implementação e altere `= delete` para `= default`. Você também pode adicionar um construtor em IDL para a classe de tempo de execução. |
| Você implementou [**INotifyPropertyChanged**](/uwp/api/windows.ui.xaml.data.inotifypropertychanged), mas suas associações XAML não estão sendo atualizadas (e a interface do usuário não está assinando [**PropertyChanged**](/uwp/api/windows.ui.xaml.data.inotifypropertychanged.PropertyChanged)). | Lembre-se de definir `Mode=OneWay` (ou TwoWay) em sua expressão de associação na marcação XAML. Confira [Controles XAML; associar a uma propriedade C++/WinRT](binding-property.md). |
| Você está associando um controle de itens XAML a uma coleção observável, e uma exceção é lançada em tempo de execução com a mensagem "O parâmetro está incorreto". | No IDL e na implementação, declare qualquer coleção observável como tipo **Windows.Foundation.Collections.IVector<IInspectable>** . Mas retorne um objeto que implementa **Windows.Foundation.Collections.IObservableVector<T>** , em que T é o tipo de elemento. Confira [Controles de itens XAML; associar a uma coleção C++/WinRT](binding-collection.md).  |
| O compilador C++ gera um erro do formulário " *'MyImplementationType_base&lt;MyImplementationType&gt;': nenhum construtor padrão apropriado disponível*".|Isso poderá acontecer quando você fizer a derivação de um tipo que tem um construtor não trivial. O construtor do tipo derivado precisa passar os parâmetros que o construtor do tipo base precisa. Para obter um exemplo trabalhado, confira [Como derivar de um tipo que tem um construtor não trivial](author-apis.md#deriving-from-a-type-that-has-a-non-default-constructor).|
| O compilador C++ gera o erro "*não é possível converter 'const std::vector&lt;std::wstring,std::allocator&lt;_Ty&gt;&gt;' em 'const winrt::param::async_iterable&lt;winrt::hstring&gt; &'* ".|Isso poderá acontecer quando você passar um std::vector de std::wstring para uma API de Windows Runtime que espera uma coleção. Para saber mais, confira [Tipos de dados C++ padrão e C++/WinRT](std-cpp-data-types.md).|
| O compilador C++ gera o erro "*não é possível converter 'const std::vector&lt;winrt::hstring,std::allocator&lt;_Ty&gt;&gt;' em 'const winrt::param::async_iterable&lt;winrt::hstring&gt; &'* ".|Isso poderá acontecer quando você passar um std::vector de winrt::hstring para uma API assíncrona do Windows Runtime que espera uma coleção e não tiver copiado nem movido o vetor para o computador chamado assíncrono. Para saber mais, confira [Tipos de dados C++ padrão e C++/WinRT](std-cpp-data-types.md).|
| Ao abrir um projeto, o Visual Studio gera o erro "*O aplicativo do projeto não está instalado*".|Se você ainda não tiver instalado as **ferramentas Universais do Windows para desenvolvimento em C++** na caixa de diálogo **Novo Projeto** do Visual Studio, precisará fazê-lo. Se isso não resolver o problema, possivelmente o projeto dependerá da Extensão do Visual Studio (VSIX) do C++/WinRT (confira [Suporte do Visual Studio para C++/WinRT](intro-to-using-cpp-with-winrt.md#visual-studio-support-for-cwinrt-xaml-the-vsix-extension-and-the-nuget-package)).|
| Os testes do Kit de Certificação de Aplicativos Windows produzem um erro que uma das suas classes de tempo de execução "*não deriva de uma classe base do Windows. Todas as classes combináveis devem derivar, por fim, de um tipo no namespace do Windows*".|Qualquer classe de tempo de execução (que você declara em seu aplicativo) que é derivada de uma classe base é conhecida como uma classe *combinável*. A classe base definitiva de uma classe combinável deve ser um tipo de origem em um namespace do Windows.*; por exemplo, [**Windows.UI.Xaml.DependencyObject**](/uwp/api/windows.ui.xaml.dependencyobject). Para obter mais detalhes, confira [Controles XAML; associar a uma propriedade C++/WinRT](binding-property.md).|
| O compilador C++ gera o erro "*deve ser do tipo WinRT*" para uma especialização de delegação de EventHandler ou TypedEventHandler.|Em vez disso, é recomendável o uso de **winrt::delegate&lt;...T&gt;** . Confira [Criar eventos em C++/WinRT](author-events.md).|
| O compilador C++ gera o erro "*deve ser do tipo WinRT*" para uma especialização de operação assíncrona do Windows Runtime.|Em vez disso, é recomendável retornar uma [**tarefa**](https://docs.microsoft.com/cpp/parallel/concrt/reference/task-class) PPL (Parallel Patterns Library). Confira [Simultaneidade e operações assíncronas](concurrency.md).|
| O compilador C++ gera "*erro C2220: aviso tratado como erro - nenhum arquivo 'object' gerado*".|Corrija o aviso ou defina **C/C++**  > **Geral** > **Tratar Avisos como Erros** como **Não (/WX-)** .|
| O aplicativo falha porque um manipulador de eventos no objeto C++/WinRT é chamado depois que o objeto é destruído.|Confira [Acessar com segurança o ponteiro *isso* com um representante de manipulação de eventos](weak-references.md#safely-accessing-the-this-pointer-with-an-event-handling-delegate).|
| O compilador C++ produz o "*erro C2338: somente para suporte a referência fraca*".|Você está solicitando uma referência fraca para um tipo que passou o struct de marcador **winrt::no_weak_ref** como um argumento de modelo para sua classe base. Confira [Como recusar o suporte de referência fraca](weak-references.md#opting-out-of-weak-reference-support).|
| O vinculador C++ produz o "*erro LNK2019: símbolo externo não resolvido*"|Confira [Por que o vinculador fornece um erro "LNK2019: erro externo não resolvido"?](faq.md#why-is-the-linker-giving-me-a-lnk2019-unresolved-external-symbol-error).|
| A cadeia de ferramentas Clang e de LLVM produz erros quando usado com C++/WinRT.|Não oferecemos suporte a cadeia de ferramentas Clang e de LLVM para C++/WinRT, mas se você quiser emular como podemos usá-lo internamente, então, você pode tentar um experimento, como aquele descrito em [Posso usar Clang/LLVM para compilar com C++/WinRT?](faq.md#can-i-use-llvmclang-to-compile-with-cwinrt).|
| O compilador C++ produz "*nenhum construtor padrão apropriado*" para um tipo projetado. | Se você estiver tentando atrasar a inicialização de um objeto de classe de tempo de execução ou consumir e implementar uma classe de tempo de execução no mesmo projeto, então precisará chamar o construtor **std::nullptr_t**. Para saber mais, confira [Consumir APIs com C++/WinRT](consume-apis.md). |
| O compilador C++ produz o "*erro C3861: 'from_abi': identificador não encontrado*" e outros erros originados no *base.h*. Você pode ver este erro se estiver usando o Visual Studio 2017 (versão 15.8.0 ou superior) e tendo como destino o SDK do Windows versão 10.0.17134.0 (Windows 10, versão 1803). | Você pode segmentar uma versão posterior (mais compatível) do SDK do Windows ou definir a propriedade do projeto **C/C++**  > **Linguagem** > **Modo de conformidade: No** (Além disso, se **/permissive--** for exibido na propriedade do projeto **C/C++**  > **Linguagem** > **Linha de Comando** em **Opções Adicionais**, então o exclua). |
| O compilador C++ produz o "*erro C2039: 'IUnknown': não é membro de '\`namespace global''* ". | Confira [Como redirecionar seu projeto C++/WinRT para uma versão posterior do SDK do Windows](news.md#how-to-retarget-your-cwinrt-project-to-a-later-version-of-the-windows-sdk). |
| O vinculador C++ produz o "*erro LNK2019: símbolo externo não resolvido _WINRT_CanUnloadNow@0 referenciado na função _VSDesignerCanUnloadNow@0* " | Confira [Como redirecionar seu projeto C++/WinRT para uma versão posterior do SDK do Windows](news.md#how-to-retarget-your-cwinrt-project-to-a-later-version-of-the-windows-sdk). |
| O processo de compilação gera a mensagem de erro *O C++/WinRT VSIX não fornece mais suporte à compilação do projeto.  Adicione uma referência de projeto para o pacote do Nuget Microsoft.Windows.CppWinRT*. | Instale o pacote do NuGet **Microsoft.Windows.CppWinRT** em seu projeto. Para obter detalhes, confira [Versões anteriores da extensão do VSIX](intro-to-using-cpp-with-winrt.md#earlier-versions-of-the-vsix-extension). |
| O vinculador C++ produz *error LNK2019: unresolved external symbol*, com uma menção *winrt::impl::consume_Windows_Foundation_Collections_IVector*. | A partir do [C++/WinRT 2.0](news.md#news-and-changes-in-cwinrt-20), se você estiver usando um `for` baseado em intervalo na coleção de tempo de execução do Windows e, em seguida, você precisará de `#include <winrt/Windows.Foundation.Collections.h>`. |
| O compilador C++ produz o "*erro C4002: Muitos argumentos para a invocação de macro do tipo função GetCurrentTime*". | Confira [Como resolver ambiguidades com GetCurrentTime e/ou TRY?](faq.md#how-do-i-resolve-ambiguities-with-getcurrenttime-andor-try). |
| O compilador C++ produz o "*erro C2334: tokens inesperados antes de '{'; ignorando o corpo aparente da função*". | Confira [Como resolver ambiguidades com GetCurrentTime e/ou TRY?](faq.md#how-do-i-resolve-ambiguities-with-getcurrenttime-andor-try). |
| O compilador C++ produz "*winrt::impl::produce&lt;D,I&gt; não pode criar uma instância da classe abstrata devido a GetBindingConnector* ausente". | Você precisa `#include <winrt/Windows.UI.Xaml.Markup.h>`. |
| O compilador C++ produz o "*erro C2039:  'promise_type': não é um membro de 'std::experimental::coroutine_traits<void>'* ". | Sua corrotina precisa retornar um objeto de operação assíncrona ou **winrt::fire_and_forget**. Confira [Simultaneidade e operações assíncronas](concurrency.md). |
| Seu projeto produz "*acesso ambíguo de 'PopulatePropertyInfoOverride'* ". | Esse erro pode ocorrer quando você declara uma classe base em seu IDL e outra classe base na marcação XAML. |
| Carregar uma solução de C++/WinRT pela primeira vez produz "*Falha no build em tempo de design para o projeto 'MyProject.vcxproj' com a configuração 'Debug\|x86'. O IntelliSense pode estar indisponível.* ". | Esse problema com o IntelliSense será resolvido após você executar o build pela primeira vez. |
| Tentar especificar [**winrt::auto_revoke**](/uwp/cpp-ref-for-winrt/auto-revoke-t) ao registrar um delegado produz uma exceção [**winrt::hresult_no_interface**](/uwp/cpp-ref-for-winrt/error-handling/hresult-no-interface). | Consulte [Se o registro de seu delegado de revogação automática falhar](handle-events.md#if-your-auto-revoke-delegate-fails-to-register). |

> [!NOTE]
> Se este tópico não solucionar sua dúvida, você pode encontrar ajuda visitando a [comunidade de desenvolvedores do Visual Studio C++](https://developercommunity.visualstudio.com/spaces/62/index.html) ou usando a marca [`c++-winrt` no Stack Overflow](https://stackoverflow.com/questions/tagged/c%2b%2b-winrt).
